/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/draftjs-to-html";
exports.ids = ["vendor-chunks/draftjs-to-html"];
exports.modules = {

/***/ "(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js":
/*!*************************************************************!*\
  !*** ./node_modules/draftjs-to-html/lib/draftjs-to-html.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDMkQ7QUFDN0QsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7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b3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanM/MWI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmRyYWZ0anNUb0h0bWwgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICogVXRpbGl0eSBmdW5jdGlvbiB0byBleGVjdXRlIGNhbGxiYWNrIGZvciBlYWNrIGtleS0+dmFsdWUgcGFpci5cbiAgKi9cbiAgZnVuY3Rpb24gZm9yRWFjaChvYmosIGNhbGxiYWNrKSB7XG4gICAgaWYgKG9iaikge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIGNhbGxiYWNrKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBwYXNzZWQgdG8gaXQgaGFzIG5vIGNvbnRlbnQuXG4gICovXG5cbiAgZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQgfHwgc3RyID09PSBudWxsIHx8IHN0ci5sZW5ndGggPT09IDAgfHwgc3RyLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAqIE1hcHBpbmcgYmxvY2stdHlwZSB0byBjb3JyZXNwb25kaW5nIGh0bWwgdGFnLlxuICAqL1xuXG4gIHZhciBibG9ja1R5cGVzTWFwcGluZyA9IHtcbiAgICB1bnN0eWxlZDogJ3AnLFxuICAgICdoZWFkZXItb25lJzogJ2gxJyxcbiAgICAnaGVhZGVyLXR3byc6ICdoMicsXG4gICAgJ2hlYWRlci10aHJlZSc6ICdoMycsXG4gICAgJ2hlYWRlci1mb3VyJzogJ2g0JyxcbiAgICAnaGVhZGVyLWZpdmUnOiAnaDUnLFxuICAgICdoZWFkZXItc2l4JzogJ2g2JyxcbiAgICAndW5vcmRlcmVkLWxpc3QtaXRlbSc6ICd1bCcsXG4gICAgJ29yZGVyZWQtbGlzdC1pdGVtJzogJ29sJyxcbiAgICBibG9ja3F1b3RlOiAnYmxvY2txdW90ZScsXG4gICAgY29kZTogJ3ByZSdcbiAgfTtcbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gSFRNTCB0YWcgZm9yIGEgYmxvY2suXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tUYWcodHlwZSkge1xuICAgIHJldHVybiB0eXBlICYmIGJsb2NrVHlwZXNNYXBwaW5nW3R5cGVdO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIHN0eWxlIHN0cmluZyBmb3IgYSBibG9jay5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRCbG9ja1N0eWxlKGRhdGEpIHtcbiAgICB2YXIgc3R5bGVzID0gJyc7XG4gICAgZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHN0eWxlcyArPSBcIlwiLmNvbmNhdChrZXksIFwiOlwiKS5jb25jYXQodmFsdWUsIFwiO1wiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIGhhc2h0YWctc2VjdGlvbnMgaW4gYmxvY2tzLlxuICAqIFRoZXNlIHdpbGwgYmUgYXJlYXMgaW4gYmxvY2sgd2hpY2ggaGF2ZSBoYXNodGFncyBhcHBsaWNhYmxlIHRvIHRoZW0uXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0SGFzaHRhZ1JhbmdlcyhibG9ja1RleHQsIGhhc2h0YWdDb25maWcpIHtcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICAgIGlmIChoYXNodGFnQ29uZmlnKSB7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgICB2YXIgdGV4dCA9IGJsb2NrVGV4dDtcbiAgICAgIHZhciB0cmlnZ2VyID0gaGFzaHRhZ0NvbmZpZy50cmlnZ2VyIHx8ICcjJztcbiAgICAgIHZhciBzZXBhcmF0b3IgPSBoYXNodGFnQ29uZmlnLnNlcGFyYXRvciB8fCAnICc7XG5cbiAgICAgIGZvciAoOyB0ZXh0Lmxlbmd0aCA+IDAgJiYgc3RhcnRJbmRleCA+PSAwOykge1xuICAgICAgICBpZiAodGV4dFswXSA9PT0gdHJpZ2dlcikge1xuICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cih0cmlnZ2VyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHRleHQuaW5kZXhPZihzZXBhcmF0b3IgKyB0cmlnZ2VyKTtcblxuICAgICAgICAgIGlmIChzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cihzdGFydEluZGV4ICsgKHNlcGFyYXRvciArIHRyaWdnZXIpLmxlbmd0aCk7XG4gICAgICAgICAgICBjb3VudGVyICs9IHN0YXJ0SW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICB2YXIgZW5kSW5kZXggPSB0ZXh0LmluZGV4T2Yoc2VwYXJhdG9yKSA+PSAwID8gdGV4dC5pbmRleE9mKHNlcGFyYXRvcikgOiB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB2YXIgaGFzaHRhZyA9IHRleHQuc3Vic3RyKDAsIGVuZEluZGV4KTtcblxuICAgICAgICAgIGlmIChoYXNodGFnICYmIGhhc2h0YWcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIG9mZnNldDogY291bnRlcixcbiAgICAgICAgICAgICAgbGVuZ3RoOiBoYXNodGFnLmxlbmd0aCArIHRyaWdnZXIubGVuZ3RoLFxuICAgICAgICAgICAgICB0eXBlOiAnSEFTSFRBRydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50ZXIgKz0gdHJpZ2dlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2YgZW50aXR5LXNlY3Rpb25zIGluIGJsb2Nrcy5cbiAgKiBUaGVzZSB3aWxsIGJlIGFyZWFzIGluIGJsb2NrIHdoaWNoIGhhdmUgc2FtZSBlbnRpdHkgb3Igbm8gZW50aXR5IGFwcGxpY2FibGUgdG8gdGhlbS5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFNlY3Rpb25zKGJsb2NrLCBoYXNodGFnQ29uZmlnKSB7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgIHZhciBzZWN0aW9uUmFuZ2VzID0gYmxvY2suZW50aXR5UmFuZ2VzLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciBvZmZzZXQgPSByYW5nZS5vZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoID0gcmFuZ2UubGVuZ3RoLFxuICAgICAgICAgIGtleSA9IHJhbmdlLmtleTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHR5cGU6ICdFTlRJVFknXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHNlY3Rpb25SYW5nZXMgPSBzZWN0aW9uUmFuZ2VzLmNvbmNhdChnZXRIYXNodGFnUmFuZ2VzKGJsb2NrLnRleHQsIGhhc2h0YWdDb25maWcpKTtcbiAgICBzZWN0aW9uUmFuZ2VzID0gc2VjdGlvblJhbmdlcy5zb3J0KGZ1bmN0aW9uIChzMSwgczIpIHtcbiAgICAgIHJldHVybiBzMS5vZmZzZXQgLSBzMi5vZmZzZXQ7XG4gICAgfSk7XG4gICAgc2VjdGlvblJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBpZiAoci5vZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiBsYXN0T2Zmc2V0LFxuICAgICAgICAgIGVuZDogci5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICBzdGFydDogci5vZmZzZXQsXG4gICAgICAgIGVuZDogci5vZmZzZXQgKyByLmxlbmd0aCxcbiAgICAgICAgZW50aXR5S2V5OiByLmtleSxcbiAgICAgICAgdHlwZTogci50eXBlXG4gICAgICB9KTtcbiAgICAgIGxhc3RPZmZzZXQgPSByLm9mZnNldCArIHIubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgaWYgKGxhc3RPZmZzZXQgPCBibG9jay50ZXh0Lmxlbmd0aCkge1xuICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBsYXN0T2Zmc2V0LFxuICAgICAgICBlbmQ6IGJsb2NrLnRleHQubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGJsb2NrIGlzIGFuIGF0b21pYyBlbnRpdHkgYmxvY2suXG4gICovXG5cblxuICBmdW5jdGlvbiBpc0F0b21pY0VudGl0eUJsb2NrKGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrLmVudGl0eVJhbmdlcy5sZW5ndGggPiAwICYmIChpc0VtcHR5U3RyaW5nKGJsb2NrLnRleHQpIHx8IGJsb2NrLnR5cGUgPT09ICdhdG9taWMnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhcnJheSBvZiBpbmxpbmUgc3R5bGVzIGFwcGxpY2FibGUgdG8gdGhlIGJsb2NrLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U3R5bGVBcnJheUZvckJsb2NrKGJsb2NrKSB7XG4gICAgdmFyIHRleHQgPSBibG9jay50ZXh0LFxuICAgICAgICBpbmxpbmVTdHlsZVJhbmdlcyA9IGJsb2NrLmlubGluZVN0eWxlUmFuZ2VzO1xuICAgIHZhciBpbmxpbmVTdHlsZXMgPSB7XG4gICAgICBCT0xEOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgSVRBTElDOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgVU5ERVJMSU5FOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgU1RSSUtFVEhST1VHSDogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIENPREU6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBTVVBFUlNDUklQVDogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIFNVQlNDUklQVDogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIENPTE9SOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgQkdDT0xPUjogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIEZPTlRTSVpFOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgRk9OVEZBTUlMWTogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIGxlbmd0aDogdGV4dC5sZW5ndGhcbiAgICB9O1xuXG4gICAgaWYgKGlubGluZVN0eWxlUmFuZ2VzICYmIGlubGluZVN0eWxlUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlubGluZVN0eWxlUmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSByYW5nZS5vZmZzZXQ7XG4gICAgICAgIHZhciBsZW5ndGggPSBvZmZzZXQgKyByYW5nZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHJhbmdlLnN0eWxlLmluZGV4T2YoJ2NvbG9yLScpID09PSAwKSB7XG4gICAgICAgICAgICBpbmxpbmVTdHlsZXMuQ09MT1JbaV0gPSByYW5nZS5zdHlsZS5zdWJzdHJpbmcoNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5zdHlsZS5pbmRleE9mKCdiZ2NvbG9yLScpID09PSAwKSB7XG4gICAgICAgICAgICBpbmxpbmVTdHlsZXMuQkdDT0xPUltpXSA9IHJhbmdlLnN0eWxlLnN1YnN0cmluZyg4KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnN0eWxlLmluZGV4T2YoJ2ZvbnRzaXplLScpID09PSAwKSB7XG4gICAgICAgICAgICBpbmxpbmVTdHlsZXMuRk9OVFNJWkVbaV0gPSByYW5nZS5zdHlsZS5zdWJzdHJpbmcoOSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5zdHlsZS5pbmRleE9mKCdmb250ZmFtaWx5LScpID09PSAwKSB7XG4gICAgICAgICAgICBpbmxpbmVTdHlsZXMuRk9OVEZBTUlMWVtpXSA9IHJhbmdlLnN0eWxlLnN1YnN0cmluZygxMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmxpbmVTdHlsZXNbcmFuZ2Uuc3R5bGVdKSB7XG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNbcmFuZ2Uuc3R5bGVdW2ldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbmxpbmVTdHlsZXM7XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGlubGluZSBzdHlsZSBhcHBsaWNhYmxlIGF0IHNvbWUgb2Zmc2V0IHdpdGhpbiBhIGJsb2NrLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U3R5bGVzQXRPZmZzZXQoaW5saW5lU3R5bGVzLCBvZmZzZXQpIHtcbiAgICB2YXIgc3R5bGVzID0ge307XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkNPTE9SW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5DT0xPUiA9IGlubGluZVN0eWxlcy5DT0xPUltvZmZzZXRdO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuQkdDT0xPUltvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuQkdDT0xPUiA9IGlubGluZVN0eWxlcy5CR0NPTE9SW29mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5GT05UU0laRVtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuRk9OVFNJWkUgPSBpbmxpbmVTdHlsZXMuRk9OVFNJWkVbb2Zmc2V0XTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkZPTlRGQU1JTFlbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkZPTlRGQU1JTFkgPSBpbmxpbmVTdHlsZXMuRk9OVEZBTUlMWVtvZmZzZXRdO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuVU5ERVJMSU5FW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5VTkRFUkxJTkUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuSVRBTElDW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5JVEFMSUMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuQk9MRFtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuQk9MRCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5TVFJJS0VUSFJPVUdIW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5TVFJJS0VUSFJPVUdIID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkNPREVbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkNPREUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuU1VCU0NSSVBUW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5TVUJTQ1JJUFQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuU1VQRVJTQ1JJUFRbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLlNVUEVSU0NSSVBUID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBmb3IgYSBzZXQgb2Ygc3R5bGVzIGlmIHRoZSB2YWx1ZSBvZiB0aGVzZSBzdHlsZXMgYXQgYW4gb2Zmc2V0XG4gICogYXJlIHNhbWUgYXMgdGhhdCBvbiB0aGUgcHJldmlvdXMgb2Zmc2V0LlxuICAqL1xuXG4gIGZ1bmN0aW9uIHNhbWVTdHlsZUFzUHJldmlvdXMoaW5saW5lU3R5bGVzLCBzdHlsZXMsIGluZGV4KSB7XG4gICAgdmFyIHNhbWVTdHlsZWQgPSB0cnVlO1xuXG4gICAgaWYgKGluZGV4ID4gMCAmJiBpbmRleCA8IGlubGluZVN0eWxlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBzYW1lU3R5bGVkID0gc2FtZVN0eWxlZCAmJiBpbmxpbmVTdHlsZXNbc3R5bGVdW2luZGV4XSA9PT0gaW5saW5lU3R5bGVzW3N0eWxlXVtpbmRleCAtIDFdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbWVTdHlsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtZVN0eWxlZDtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiByZXR1cm5zIGh0bWwgZm9yIHRleHQgZGVwZW5kaW5nIG9uIGlubGluZSBzdHlsZSB0YWdzIGFwcGxpY2FibGUgdG8gaXQuXG4gICovXG5cbiAgZnVuY3Rpb24gYWRkSW5saW5lU3R5bGVNYXJrdXAoc3R5bGUsIGNvbnRlbnQpIHtcbiAgICBpZiAoc3R5bGUgPT09ICdCT0xEJykge1xuICAgICAgcmV0dXJuIFwiPHN0cm9uZz5cIi5jb25jYXQoY29udGVudCwgXCI8L3N0cm9uZz5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnSVRBTElDJykge1xuICAgICAgcmV0dXJuIFwiPGVtPlwiLmNvbmNhdChjb250ZW50LCBcIjwvZW0+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ1VOREVSTElORScpIHtcbiAgICAgIHJldHVybiBcIjxpbnM+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9pbnM+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ1NUUklLRVRIUk9VR0gnKSB7XG4gICAgICByZXR1cm4gXCI8ZGVsPlwiLmNvbmNhdChjb250ZW50LCBcIjwvZGVsPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdDT0RFJykge1xuICAgICAgcmV0dXJuIFwiPGNvZGU+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9jb2RlPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdTVVBFUlNDUklQVCcpIHtcbiAgICAgIHJldHVybiBcIjxzdXA+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9zdXA+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ1NVQlNDUklQVCcpIHtcbiAgICAgIHJldHVybiBcIjxzdWI+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9zdWI+XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRleHQgZm9yIGdpdmVuIHNlY3Rpb24gb2YgYmxvY2sgYWZ0ZXIgZG9pbmcgcmVxdWlyZWQgY2hhcmFjdGVyIHJlcGxhY2VtZW50cy5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRTZWN0aW9uVGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgY2hhcnMgPSB0ZXh0Lm1hcChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICByZXR1cm4gJzxicj4nO1xuXG4gICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcblxuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcblxuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiByZXR1cm5zIGh0bWwgZm9yIHRleHQgZGVwZW5kaW5nIG9uIGlubGluZSBzdHlsZSB0YWdzIGFwcGxpY2FibGUgdG8gaXQuXG4gICovXG5cblxuICBmdW5jdGlvbiBhZGRTdHlsZVByb3BlcnR5TWFya3VwKHN0eWxlcywgdGV4dCkge1xuICAgIGlmIChzdHlsZXMgJiYgKHN0eWxlcy5DT0xPUiB8fCBzdHlsZXMuQkdDT0xPUiB8fCBzdHlsZXMuRk9OVFNJWkUgfHwgc3R5bGVzLkZPTlRGQU1JTFkpKSB7XG4gICAgICB2YXIgc3R5bGVTdHJpbmcgPSAnc3R5bGU9XCInO1xuXG4gICAgICBpZiAoc3R5bGVzLkNPTE9SKSB7XG4gICAgICAgIHN0eWxlU3RyaW5nICs9IFwiY29sb3I6IFwiLmNvbmNhdChzdHlsZXMuQ09MT1IsIFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlcy5CR0NPTE9SKSB7XG4gICAgICAgIHN0eWxlU3RyaW5nICs9IFwiYmFja2dyb3VuZC1jb2xvcjogXCIuY29uY2F0KHN0eWxlcy5CR0NPTE9SLCBcIjtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZXMuRk9OVFNJWkUpIHtcbiAgICAgICAgc3R5bGVTdHJpbmcgKz0gXCJmb250LXNpemU6IFwiLmNvbmNhdChzdHlsZXMuRk9OVFNJWkUpLmNvbmNhdCgvXlxcZCskLy50ZXN0KHN0eWxlcy5GT05UU0laRSkgPyAncHgnIDogJycsIFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlcy5GT05URkFNSUxZKSB7XG4gICAgICAgIHN0eWxlU3RyaW5nICs9IFwiZm9udC1mYW1pbHk6IFwiLmNvbmNhdChzdHlsZXMuRk9OVEZBTUlMWSwgXCI7XCIpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVN0cmluZyArPSAnXCInO1xuICAgICAgcmV0dXJuIFwiPHNwYW4gXCIuY29uY2F0KHN0eWxlU3RyaW5nLCBcIj5cIikuY29uY2F0KHRleHQsIFwiPC9zcGFuPlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiBtYXJrdXAgZm9yIEVudGl0eS5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRFbnRpdHlNYXJrdXAoZW50aXR5TWFwLCBlbnRpdHlLZXksIHRleHQsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlNYXBbZW50aXR5S2V5XTtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9tRW50aXR5VHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaHRtbCA9IGN1c3RvbUVudGl0eVRyYW5zZm9ybShlbnRpdHksIHRleHQpO1xuXG4gICAgICBpZiAoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50aXR5LnR5cGUgPT09ICdNRU5USU9OJykge1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIuY29uY2F0KGVudGl0eS5kYXRhLnVybCwgXCJcXFwiIGNsYXNzPVxcXCJ3eXNpd3lnLW1lbnRpb25cXFwiIGRhdGEtbWVudGlvbiBkYXRhLXZhbHVlPVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLnZhbHVlLCBcIlxcXCI+XCIpLmNvbmNhdCh0ZXh0LCBcIjwvYT5cIik7XG4gICAgfVxuXG4gICAgaWYgKGVudGl0eS50eXBlID09PSAnTElOSycpIHtcbiAgICAgIHZhciB0YXJnZXRPcHRpb24gPSBlbnRpdHkuZGF0YS50YXJnZXRPcHRpb24gfHwgJ19zZWxmJztcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiLmNvbmNhdChlbnRpdHkuZGF0YS51cmwsIFwiXFxcIiB0YXJnZXQ9XFxcIlwiKS5jb25jYXQodGFyZ2V0T3B0aW9uLCBcIlxcXCI+XCIpLmNvbmNhdCh0ZXh0LCBcIjwvYT5cIik7XG4gICAgfVxuXG4gICAgaWYgKGVudGl0eS50eXBlID09PSAnSU1BR0UnKSB7XG4gICAgICB2YXIgYWxpZ25tZW50ID0gZW50aXR5LmRhdGEuYWxpZ25tZW50O1xuXG4gICAgICBpZiAoYWxpZ25tZW50ICYmIGFsaWdubWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFwiPGRpdiBzdHlsZT1cXFwidGV4dC1hbGlnbjpcIi5jb25jYXQoYWxpZ25tZW50LCBcIjtcXFwiPjxpbWcgc3JjPVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLnNyYywgXCJcXFwiIGFsdD1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5hbHQsIFwiXFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiBcIikuY29uY2F0KGVudGl0eS5kYXRhLmhlaWdodCwgXCI7d2lkdGg6IFwiKS5jb25jYXQoZW50aXR5LmRhdGEud2lkdGgsIFwiXFxcIi8+PC9kaXY+XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI8aW1nIHNyYz1cXFwiXCIuY29uY2F0KGVudGl0eS5kYXRhLnNyYywgXCJcXFwiIGFsdD1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5hbHQsIFwiXFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiBcIikuY29uY2F0KGVudGl0eS5kYXRhLmhlaWdodCwgXCI7d2lkdGg6IFwiKS5jb25jYXQoZW50aXR5LmRhdGEud2lkdGgsIFwiXFxcIi8+XCIpO1xuICAgIH1cblxuICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ0VNQkVEREVEX0xJTksnKSB7XG4gICAgICByZXR1cm4gXCI8aWZyYW1lIHdpZHRoPVxcXCJcIi5jb25jYXQoZW50aXR5LmRhdGEud2lkdGgsIFwiXFxcIiBoZWlnaHQ9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEuaGVpZ2h0LCBcIlxcXCIgc3JjPVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLnNyYywgXCJcXFwiIGZyYW1lQm9yZGVyPVxcXCIwXFxcIj48L2lmcmFtZT5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICogRm9yIGEgZ2l2ZW4gc2VjdGlvbiBpbiBhIGJsb2NrIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIGZ1cnRoZXIgbGlzdCBvZiBzZWN0aW9ucyxcbiAgKiB3aXRoIHNpbWlsYXIgaW5saW5lIHN0eWxlcyBhcHBsaWNhYmxlIHRvIHRoZW0uXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRJbmxpbmVTdHlsZVNlY3Rpb25zKGJsb2NrLCBzdHlsZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3R5bGVTZWN0aW9ucyA9IFtdO1xuICAgIHZhciB0ZXh0ID0gQXJyYXkuZnJvbShibG9jay50ZXh0KTtcblxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpbmxpbmVTdHlsZXMgPSBnZXRTdHlsZUFycmF5Rm9yQmxvY2soYmxvY2spO1xuICAgICAgdmFyIHNlY3Rpb247XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpICE9PSBzdGFydCAmJiBzYW1lU3R5bGVBc1ByZXZpb3VzKGlubGluZVN0eWxlcywgc3R5bGVzLCBpKSkge1xuICAgICAgICAgIHNlY3Rpb24udGV4dC5wdXNoKHRleHRbaV0pO1xuICAgICAgICAgIHNlY3Rpb24uZW5kID0gaSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0eWxlczogZ2V0U3R5bGVzQXRPZmZzZXQoaW5saW5lU3R5bGVzLCBpKSxcbiAgICAgICAgICAgIHRleHQ6IFt0ZXh0W2ldXSxcbiAgICAgICAgICAgIHN0YXJ0OiBpLFxuICAgICAgICAgICAgZW5kOiBpICsgMVxuICAgICAgICAgIH07XG4gICAgICAgICAgc3R5bGVTZWN0aW9ucy5wdXNoKHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlU2VjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICogUmVwbGFjZSBsZWFkaW5nIGJsYW5rIHNwYWNlcyBieSAmbmJzcDtcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIHRyaW1MZWFkaW5nWmVyb3Moc2VjdGlvblRleHQpIHtcbiAgICBpZiAoc2VjdGlvblRleHQpIHtcbiAgICAgIHZhciByZXBsYWNlZFRleHQgPSBzZWN0aW9uVGV4dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlZFRleHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNlY3Rpb25UZXh0W2ldID09PSAnICcpIHtcbiAgICAgICAgICByZXBsYWNlZFRleHQgPSByZXBsYWNlZFRleHQucmVwbGFjZSgnICcsICcmbmJzcDsnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVwbGFjZWRUZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uVGV4dDtcbiAgfVxuICAvKipcbiAgKiBSZXBsYWNlIHRyYWlsaW5nIGJsYW5rIHNwYWNlcyBieSAmbmJzcDtcbiAgKi9cblxuICBmdW5jdGlvbiB0cmltVHJhaWxpbmdaZXJvcyhzZWN0aW9uVGV4dCkge1xuICAgIGlmIChzZWN0aW9uVGV4dCkge1xuICAgICAgdmFyIHJlcGxhY2VkVGV4dCA9IHNlY3Rpb25UZXh0O1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVwbGFjZWRUZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmIChyZXBsYWNlZFRleHRbaV0gPT09ICcgJykge1xuICAgICAgICAgIHJlcGxhY2VkVGV4dCA9IFwiXCIuY29uY2F0KHJlcGxhY2VkVGV4dC5zdWJzdHJpbmcoMCwgaSksIFwiJm5ic3A7XCIpLmNvbmNhdChyZXBsYWNlZFRleHQuc3Vic3RyaW5nKGkgKyAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcGxhY2VkVGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvblRleHQ7XG4gIH1cbiAgLyoqXG4gICogVGhlIG1ldGhvZCByZXR1cm5zIG1hcmt1cCBmb3Igc2VjdGlvbiB0byB3aGljaCBpbmxpbmUgc3R5bGVzXG4gICogbGlrZSBCT0xELCBJVEFMSUMsIFVOREVSTElORSwgU1RSSUtFVEhST1VHSCwgQ09ERSwgU1VQRVJTQ1JJUFQsIFNVQlNDUklQVCBhcmUgYXBwbGljYWJsZS5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRTdHlsZVRhZ1NlY3Rpb25NYXJrdXAoc3R5bGVTZWN0aW9uKSB7XG4gICAgdmFyIHN0eWxlcyA9IHN0eWxlU2VjdGlvbi5zdHlsZXMsXG4gICAgICAgIHRleHQgPSBzdHlsZVNlY3Rpb24udGV4dDtcbiAgICB2YXIgY29udGVudCA9IGdldFNlY3Rpb25UZXh0KHRleHQpO1xuICAgIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlKSB7XG4gICAgICBjb250ZW50ID0gYWRkSW5saW5lU3R5bGVNYXJrdXAoc3R5bGUsIGNvbnRlbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIC8qKlxuICAqIFRoZSBtZXRob2QgcmV0dXJucyBtYXJrdXAgZm9yIHNlY3Rpb24gdG8gd2hpY2ggaW5saW5lIHN0eWxlc1xuICBsaWtlIGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBmb250LXNpemUgYXJlIGFwcGxpY2FibGUuXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRJbmxpbmVTdHlsZVNlY3Rpb25NYXJrdXAoYmxvY2ssIHN0eWxlU2VjdGlvbikge1xuICAgIHZhciBzdHlsZVRhZ1NlY3Rpb25zID0gZ2V0SW5saW5lU3R5bGVTZWN0aW9ucyhibG9jaywgWydCT0xEJywgJ0lUQUxJQycsICdVTkRFUkxJTkUnLCAnU1RSSUtFVEhST1VHSCcsICdDT0RFJywgJ1NVUEVSU0NSSVBUJywgJ1NVQlNDUklQVCddLCBzdHlsZVNlY3Rpb24uc3RhcnQsIHN0eWxlU2VjdGlvbi5lbmQpO1xuICAgIHZhciBzdHlsZVNlY3Rpb25UZXh0ID0gJyc7XG4gICAgc3R5bGVUYWdTZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVByb3BlcnR5U2VjdGlvbikge1xuICAgICAgc3R5bGVTZWN0aW9uVGV4dCArPSBnZXRTdHlsZVRhZ1NlY3Rpb25NYXJrdXAoc3R5bGVQcm9wZXJ0eVNlY3Rpb24pO1xuICAgIH0pO1xuICAgIHN0eWxlU2VjdGlvblRleHQgPSBhZGRTdHlsZVByb3BlcnR5TWFya3VwKHN0eWxlU2VjdGlvbi5zdHlsZXMsIHN0eWxlU2VjdGlvblRleHQpO1xuICAgIHJldHVybiBzdHlsZVNlY3Rpb25UZXh0O1xuICB9XG4gIC8qXG4gICogVGhlIG1ldGhvZCByZXR1cm5zIG1hcmt1cCBmb3IgYW4gZW50aXR5IHNlY3Rpb24uXG4gICogQW4gZW50aXR5IHNlY3Rpb24gaXMgYSBjb250aW51b3VzIHNlY3Rpb24gaW4gYSBibG9ja1xuICAqIHRvIHdoaWNoIHNhbWUgZW50aXR5IG9yIG5vIGVudGl0eSBpcyBhcHBsaWNhYmxlLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2VjdGlvbk1hcmt1cChibG9jaywgZW50aXR5TWFwLCBzZWN0aW9uLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgZW50aXR5SW5saW5lTWFya3VwID0gW107XG4gICAgdmFyIGlubGluZVN0eWxlU2VjdGlvbnMgPSBnZXRJbmxpbmVTdHlsZVNlY3Rpb25zKGJsb2NrLCBbJ0NPTE9SJywgJ0JHQ09MT1InLCAnRk9OVFNJWkUnLCAnRk9OVEZBTUlMWSddLCBzZWN0aW9uLnN0YXJ0LCBzZWN0aW9uLmVuZCk7XG4gICAgaW5saW5lU3R5bGVTZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVNlY3Rpb24pIHtcbiAgICAgIGVudGl0eUlubGluZU1hcmt1cC5wdXNoKGdldElubGluZVN0eWxlU2VjdGlvbk1hcmt1cChibG9jaywgc3R5bGVTZWN0aW9uKSk7XG4gICAgfSk7XG4gICAgdmFyIHNlY3Rpb25UZXh0ID0gZW50aXR5SW5saW5lTWFya3VwLmpvaW4oJycpO1xuXG4gICAgaWYgKHNlY3Rpb24udHlwZSA9PT0gJ0VOVElUWScpIHtcbiAgICAgIGlmIChzZWN0aW9uLmVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIHNlY3Rpb24uZW50aXR5S2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHNlY3Rpb25UZXh0ID0gZ2V0RW50aXR5TWFya3VwKGVudGl0eU1hcCwgc2VjdGlvbi5lbnRpdHlLZXksIHNlY3Rpb25UZXh0LCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNlY3Rpb24udHlwZSA9PT0gJ0hBU0hUQUcnKSB7XG4gICAgICBzZWN0aW9uVGV4dCA9IFwiPGEgaHJlZj1cXFwiXCIuY29uY2F0KHNlY3Rpb25UZXh0LCBcIlxcXCIgY2xhc3M9XFxcInd5c2l3eWctaGFzaHRhZ1xcXCI+XCIpLmNvbmNhdChzZWN0aW9uVGV4dCwgXCI8L2E+XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uVGV4dDtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgbWFya3VwIGZvciBibG9jayBwcmVzZXJ2aW5nIHRoZSBpbmxpbmUgc3R5bGVzIGFuZFxuICAqIHNwZWNpYWwgY2hhcmFjdGVycyBsaWtlIG5ld2xpbmVzIG9yIGJsYW5rIHNwYWNlcy5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrSW5uZXJNYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGJsb2NrTWFya3VwID0gW107XG4gICAgdmFyIHNlY3Rpb25zID0gZ2V0U2VjdGlvbnMoYmxvY2ssIGhhc2h0YWdDb25maWcpO1xuICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24sIGluZGV4KSB7XG4gICAgICB2YXIgc2VjdGlvblRleHQgPSBnZXRTZWN0aW9uTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIHNlY3Rpb24sIGN1c3RvbUVudGl0eVRyYW5zZm9ybSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBzZWN0aW9uVGV4dCA9IHRyaW1MZWFkaW5nWmVyb3Moc2VjdGlvblRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHNlY3Rpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc2VjdGlvblRleHQgPSB0cmltVHJhaWxpbmdaZXJvcyhzZWN0aW9uVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrTWFya3VwLnB1c2goc2VjdGlvblRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBibG9ja01hcmt1cC5qb2luKCcnKTtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiBodG1sIGZvciB0aGUgYmxvY2suXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tNYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBibG9ja0h0bWwgPSBbXTtcblxuICAgIGlmIChpc0F0b21pY0VudGl0eUJsb2NrKGJsb2NrKSkge1xuICAgICAgYmxvY2tIdG1sLnB1c2goZ2V0RW50aXR5TWFya3VwKGVudGl0eU1hcCwgYmxvY2suZW50aXR5UmFuZ2VzWzBdLmtleSwgdW5kZWZpbmVkLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJsb2NrVGFnID0gZ2V0QmxvY2tUYWcoYmxvY2sudHlwZSk7XG5cbiAgICAgIGlmIChibG9ja1RhZykge1xuICAgICAgICBibG9ja0h0bWwucHVzaChcIjxcIi5jb25jYXQoYmxvY2tUYWcpKTtcbiAgICAgICAgdmFyIGJsb2NrU3R5bGUgPSBnZXRCbG9ja1N0eWxlKGJsb2NrLmRhdGEpO1xuXG4gICAgICAgIGlmIChibG9ja1N0eWxlKSB7XG4gICAgICAgICAgYmxvY2tIdG1sLnB1c2goXCIgc3R5bGU9XFxcIlwiLmNvbmNhdChibG9ja1N0eWxlLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbmFsKSB7XG4gICAgICAgICAgYmxvY2tIdG1sLnB1c2goJyBkaXIgPSBcImF1dG9cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2tIdG1sLnB1c2goJz4nKTtcbiAgICAgICAgYmxvY2tIdG1sLnB1c2goZ2V0QmxvY2tJbm5lck1hcmt1cChibG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pKTtcbiAgICAgICAgYmxvY2tIdG1sLnB1c2goXCI8L1wiLmNvbmNhdChibG9ja1RhZywgXCI+XCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBibG9ja0h0bWwucHVzaCgnXFxuJyk7XG4gICAgcmV0dXJuIGJsb2NrSHRtbC5qb2luKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgYmxvY2sgaXMgb2YgdHlwZSBsaXN0LlxuICAqL1xuXG4gIGZ1bmN0aW9uIGlzTGlzdChibG9ja1R5cGUpIHtcbiAgICByZXR1cm4gYmxvY2tUeXBlID09PSAndW5vcmRlcmVkLWxpc3QtaXRlbScgfHwgYmxvY2tUeXBlID09PSAnb3JkZXJlZC1saXN0LWl0ZW0nO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIGh0bWwgbWFya3VwIGZvciBhIGxpc3QgYmxvY2suXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0TGlzdE1hcmt1cChsaXN0QmxvY2tzLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgbGlzdEh0bWwgPSBbXTtcbiAgICB2YXIgbmVzdGVkTGlzdEJsb2NrID0gW107XG4gICAgdmFyIHByZXZpb3VzQmxvY2s7XG4gICAgbGlzdEJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgdmFyIG5lc3RlZEJsb2NrID0gZmFsc2U7XG5cbiAgICAgIGlmICghcHJldmlvdXNCbG9jaykge1xuICAgICAgICBsaXN0SHRtbC5wdXNoKFwiPFwiLmNvbmNhdChnZXRCbG9ja1RhZyhibG9jay50eXBlKSwgXCI+XFxuXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNCbG9jay50eXBlICE9PSBibG9jay50eXBlKSB7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goXCI8L1wiLmNvbmNhdChnZXRCbG9ja1RhZyhwcmV2aW91c0Jsb2NrLnR5cGUpLCBcIj5cXG5cIikpO1xuICAgICAgICBsaXN0SHRtbC5wdXNoKFwiPFwiLmNvbmNhdChnZXRCbG9ja1RhZyhibG9jay50eXBlKSwgXCI+XFxuXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNCbG9jay5kZXB0aCA9PT0gYmxvY2suZGVwdGgpIHtcbiAgICAgICAgaWYgKG5lc3RlZExpc3RCbG9jayAmJiBuZXN0ZWRMaXN0QmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxpc3RIdG1sLnB1c2goZ2V0TGlzdE1hcmt1cChuZXN0ZWRMaXN0QmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkpO1xuICAgICAgICAgIG5lc3RlZExpc3RCbG9jayA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXN0ZWRCbG9jayA9IHRydWU7XG4gICAgICAgIG5lc3RlZExpc3RCbG9jay5wdXNoKGJsb2NrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXN0ZWRCbG9jaykge1xuICAgICAgICBsaXN0SHRtbC5wdXNoKCc8bGknKTtcbiAgICAgICAgdmFyIGJsb2NrU3R5bGUgPSBnZXRCbG9ja1N0eWxlKGJsb2NrLmRhdGEpO1xuXG4gICAgICAgIGlmIChibG9ja1N0eWxlKSB7XG4gICAgICAgICAgbGlzdEh0bWwucHVzaChcIiBzdHlsZT1cXFwiXCIuY29uY2F0KGJsb2NrU3R5bGUsIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgICBsaXN0SHRtbC5wdXNoKCcgZGlyID0gXCJhdXRvXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RIdG1sLnB1c2goJz4nKTtcbiAgICAgICAgbGlzdEh0bWwucHVzaChnZXRCbG9ja0lubmVyTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkpO1xuICAgICAgICBsaXN0SHRtbC5wdXNoKCc8L2xpPlxcbicpO1xuICAgICAgICBwcmV2aW91c0Jsb2NrID0gYmxvY2s7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobmVzdGVkTGlzdEJsb2NrICYmIG5lc3RlZExpc3RCbG9jay5sZW5ndGggPiAwKSB7XG4gICAgICBsaXN0SHRtbC5wdXNoKGdldExpc3RNYXJrdXAobmVzdGVkTGlzdEJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pKTtcbiAgICB9XG5cbiAgICBsaXN0SHRtbC5wdXNoKFwiPC9cIi5jb25jYXQoZ2V0QmxvY2tUYWcocHJldmlvdXNCbG9jay50eXBlKSwgXCI+XFxuXCIpKTtcbiAgICByZXR1cm4gbGlzdEh0bWwuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZSBodG1sIG1hcmt1cCBmb3IgZ2l2ZW4gZHJhZnRqcyBlZGl0b3JDb250ZW50LlxuICAqL1xuXG4gIGZ1bmN0aW9uIGRyYWZ0VG9IdG1sKGVkaXRvckNvbnRlbnQsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgaHRtbCA9IFtdO1xuXG4gICAgaWYgKGVkaXRvckNvbnRlbnQpIHtcbiAgICAgIHZhciBibG9ja3MgPSBlZGl0b3JDb250ZW50LmJsb2NrcyxcbiAgICAgICAgICBlbnRpdHlNYXAgPSBlZGl0b3JDb250ZW50LmVudGl0eU1hcDtcblxuICAgICAgaWYgKGJsb2NrcyAmJiBibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGlzdEJsb2NrcyA9IFtdO1xuICAgICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICBpZiAoaXNMaXN0KGJsb2NrLnR5cGUpKSB7XG4gICAgICAgICAgICBsaXN0QmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGlzdEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBsaXN0SHRtbCA9IGdldExpc3RNYXJrdXAobGlzdEJsb2NrcywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxuICAgICAgICAgICAgICBodG1sLnB1c2gobGlzdEh0bWwpO1xuICAgICAgICAgICAgICBsaXN0QmxvY2tzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBibG9ja0h0bWwgPSBnZXRCbG9ja01hcmt1cChibG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGh0bWwucHVzaChibG9ja0h0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxpc3RCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsaXN0SHRtbCA9IGdldExpc3RNYXJrdXAobGlzdEJsb2NrcywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbiAgICAgICAgICBodG1sLnB1c2gobGlzdEh0bWwpO1xuICAgICAgICAgIGxpc3RCbG9ja3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodG1sLmpvaW4oJycpO1xuICB9XG5cbiAgcmV0dXJuIGRyYWZ0VG9IdG1sO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js\n");

/***/ })

};
;