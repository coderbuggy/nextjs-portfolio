"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadAbortedError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError),\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   isValidFileSize: () => (/* binding */ isValidFileSize),\n/* harmony export */   isValidFileType: () => (/* binding */ isValidFileType),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var effect_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! effect/Array */ \"(ssr)/./node_modules/effect/dist/esm/Array.js\");\n/* harmony import */ var effect_Function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! effect/Function */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var effect_Micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! effect/Micro */ \"(ssr)/./node_modules/effect/dist/esm/Micro.js\");\n/* harmony import */ var effect_Option__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! effect/Option */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n\n\n\n\n\n\n\n\nvar version$1 = \"6.13.3\";\n\nconst uploadMultipartWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n        let uploadedBytes = 0;\n        const etags = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(presigned.urls, (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            return uploadPart({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((tag)=>({\n                    tag,\n                    partNumber: index + 1\n                })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n                while: (error)=>error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError,\n                times: std_env__WEBPACK_IMPORTED_MODULE_2__.isTest ? 3 : 10,\n                schedule: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n            }));\n        }, {\n            concurrency: \"inherit\"\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tapError((error)=>opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: presigned.uploadId,\n                fileName: file.name,\n                storageProviderError: String(error)\n            })));\n        // Tell the server that the upload is complete\n        yield* opts.reportEventToUT(\"multipart-complete\", {\n            uploadId: presigned.uploadId,\n            fileKey: presigned.key,\n            etags\n        });\n    });\nconst uploadPart = (opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.addEventListener(\"load\", ()=>{\n            const etag = xhr.getResponseHeader(\"Etag\");\n            if (xhr.status >= 200 && xhr.status <= 299 && etag) {\n                return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(etag));\n            }\n            return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()));\n        });\n        xhr.addEventListener(\"error\", ()=>resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError())));\n        let lastProgress = 0;\n        xhr.upload.addEventListener(\"progress\", (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        });\n        xhr.send(opts.chunk);\n        // Cleanup function that runs on interruption\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>xhr.abort());\n    });\n\nconst uploadPresignedPostWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.addEventListener(\"progress\", ({ loaded, total })=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: loaded / total * 100\n            });\n        });\n        xhr.addEventListener(\"load\", ()=>resume(xhr.status >= 200 && xhr.status < 300 ? effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(null) : opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name,\n                storageProviderError: xhr.responseText\n            })));\n        xhr.addEventListener(\"error\", ()=>resume(opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name\n            })));\n        const formData = new FormData();\n        Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n        formData.append(\"file\", file); // File data **MUST GO LAST**\n        xhr.send(formData);\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>{\n            xhr.abort();\n        });\n    });\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L112\"\n */ const createUTReporter = (cfg)=>(type, payload)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n            const url = createAPIRequestUrl({\n                url: cfg.url,\n                slug: cfg.endpoint,\n                actionType: type\n            });\n            let headers = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n            if (headers instanceof Promise) {\n                headers = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.promise(()=>headers);\n            }\n            const response = yield* (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(url, {\n                method: \"POST\",\n                body: JSON.stringify(payload),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-uploadthing-package\": cfg.package,\n                    \"x-uploadthing-version\": version$1,\n                    ...headers\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.andThen(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), /**\n         * We don't _need_ to validate the response here, just cast it for now.\n         * As of now, @effect/schema includes quite a few bytes we cut out by this...\n         * We have \"strong typing\" on the backend that ensures the shape should match.\n         */ effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"FetchError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: `Failed to report event \"${type}\" to UploadThing server`,\n                    cause: e\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n                    message: e.getMessage(),\n                    cause: e.json\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"InvalidJson\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: \"Failed to parse response from UploadThing server\",\n                    cause: e\n                }))));\n            switch(type){\n                case \"failure\":\n                    {\n                        // why isn't this narrowed automatically?\n                        const p = payload;\n                        const parsed = maybeParseResponseXML(p.storageProviderError ?? \"\");\n                        if (parsed?.message) {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: parsed.code,\n                                message: parsed.message\n                            });\n                        } else {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Failed to upload file ${p.fileName} to S3`,\n                                cause: p.storageProviderError\n                            });\n                        }\n                    }\n            }\n            return response;\n        });\n\nconst version = version$1;\n/**\n * Validate that a file is of a valid type given a route config\n * @public\n */ const isValidFileType = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((type)=>file.type.includes(type)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Validate that a file is of a valid size given a route config\n * @public\n */ const isValidFileSize = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((type)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fileSizeToBytes)(routeConfig[type].maxFileSize)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((maxFileSize)=>file.size <= maxFileSize), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Generate a typed uploader for a given FileRouter\n * @public\n */ const genUploader = (initOpts)=>{\n    return (endpoint, opts)=>uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            input: opts.input\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.provideService(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.FetchContext, {\n            fetch: globalThis.fetch.bind(globalThis),\n            baseHeaders: {\n                \"x-uploadthing-version\": version$1,\n                \"x-uploadthing-api-key\": undefined,\n                \"x-uploadthing-fe-package\": initOpts.package,\n                \"x-uploadthing-be-adapter\": undefined\n            }\n        }), (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runPromiseExit(e, opts.signal ? {\n                signal: opts.signal\n            } : {})).then((exit)=>{\n            if (exit._tag === \"Right\") {\n                return exit.right;\n            } else if (exit.left._tag === \"Interrupt\") {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError();\n            }\n            throw effect_Micro__WEBPACK_IMPORTED_MODULE_1__.causeSquash(exit.left);\n        });\n};\nconst uploadFilesInternal = (endpoint, opts)=>{\n    // classic service right here\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        package: opts.package,\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.url),\n        headers: opts.headers\n    });\n    return reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((responses)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(responses, (presigned)=>uploadFile(String(endpoint), {\n                ...opts,\n                reportEventToUT\n            }, presigned).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.onInterrupt(reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: \"uploadId\" in presigned ? presigned.uploadId : null,\n                fileName: presigned.fileName\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.ignore))), {\n            concurrency: 6\n        })));\n};\nconst isPollingResponse = (input)=>{\n    if (!(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) return false;\n    if (input.status === \"done\") return \"callbackData\" in input;\n    return input.status === \"still waiting\";\n};\nconst isPollingDone = (input)=>{\n    return input.status === \"done\";\n};\nconst uploadFile = (slug, opts, presigned)=>effect_Array__WEBPACK_IMPORTED_MODULE_4__.findFirst(opts.files, (file)=>file.name === presigned.fileName).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fromOption, effect_Micro__WEBPACK_IMPORTED_MODULE_1__.mapError(()=>{\n        // eslint-disable-next-line no-console\n        console.error(\"No file found for presigned URL\", presigned);\n        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"NOT_FOUND\",\n            message: \"No file found for presigned URL\",\n            cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n        });\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>opts.onUploadBegin?.({\n            file: file.name\n        })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>\"urls\" in presigned ? uploadMultipartWithProgress(file, presigned, opts) : uploadPresignedPostWithProgress(file, presigned, opts)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.zip((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(presigned.pollingUrl, {\n        headers: {\n            authorization: presigned.pollingJwt\n        }\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n            message: e.message,\n            cause: e\n        }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFailCause(isPollingResponse, (_)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.causeDie(\"received a non PollingResponse from the polling endpoint\")), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFail(isPollingDone, ()=>new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(({ callbackData })=>callbackData), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n        while: (res)=>res._tag === \"RetryError\",\n        schedule: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.when(()=>!opts.skipPolling), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Option__WEBPACK_IMPORTED_MODULE_5__.getOrNull), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(([file, serverData])=>({\n            name: file.name,\n            size: file.size,\n            key: presigned.key,\n            serverData,\n            url: presigned.fileUrl,\n            appUrl: presigned.appUrl,\n            customId: presigned.customId,\n            type: file.type\n        })));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ1c7QUFDVDtBQUNFO0FBQzRPO0FBQzlJO0FBQ3JHOztBQUVqQzs7QUFFQSw2REFBNkQsNkNBQVM7QUFDdEU7QUFDQSw2QkFBNkIsaURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPLDZDQUFTO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSwrQ0FBVztBQUNoQyxpREFBaUQsMkRBQVU7QUFDM0QsdUJBQXVCLDJDQUFNO0FBQzdCLDBCQUEwQixxRUFBZ0I7QUFDMUMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVMsT0FBTyxrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCwyQkFBMkIsK0NBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVFQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWE7QUFDM0M7QUFDQSwwQkFBMEIsOENBQVUsS0FBSywyREFBVTtBQUNuRCxTQUFTO0FBQ1QsaURBQWlELDhDQUFVLEtBQUssMkRBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSw4Q0FBVTtBQUN6QixLQUFLOztBQUVMLGlFQUFpRSwrQ0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULHdGQUF3RixpREFBYTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNB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QVMsSUFBSSw2Q0FBUyw2SUFBNkksNkNBQVMsQ0FBQyw2REFBUTtBQUNyTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8saURBQWEsQ0FBQyxrRUFBaUIsR0FBRyxrREFBYyx5QkFBeUIsOENBQVUsS0FBSyxpRUFBZ0I7QUFDcEgsa0JBQWtCLCtFQUEwQjtBQUM1QztBQUNBO0FBQ0EsU0FBUyxLQUFLLDJEQUF1Qix5QkFBeUIsa0RBQWMsK0RBQStELHNEQUFrQix3QkFBd0IsMkRBQVUsS0FBSyw2Q0FBUyxJQUFJLGNBQWMsa0JBQWtCLCtDQUFXO0FBQzVQO0FBQ0Esa0JBQWtCLHFFQUFnQjtBQUNsQyxLQUFLLEdBQUcsOENBQVUseUJBQXlCLDZDQUFTLENBQUMsb0RBQWdCLEdBQUcsNkNBQVMsQ0FBQyx5REFBWSxLQUFLLDZDQUFTO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUV5RCIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy91cGxvYWR0aGluZy9jbGllbnQvaW5kZXguanM/MWIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBcnIgZnJvbSAnZWZmZWN0L0FycmF5JztcbmltcG9ydCB7IHVuc2FmZUNvZXJjZSB9IGZyb20gJ2VmZmVjdC9GdW5jdGlvbic7XG5pbXBvcnQgKiBhcyBNaWNybyBmcm9tICdlZmZlY3QvTWljcm8nO1xuaW1wb3J0ICogYXMgT3B0aW9uIGZyb20gJ2VmZmVjdC9PcHRpb24nO1xuaW1wb3J0IHsgUmV0cnlFcnJvciwgZXhwb25lbnRpYWxEZWxheSwgY29udGVudERpc3Bvc2l0aW9uLCBmZXRjaEVmZiwgcGFyc2VSZXNwb25zZUpzb24sIFVwbG9hZFRoaW5nRXJyb3IsIGdldEVycm9yVHlwZUZyb21TdGF0dXNDb2RlLCBnZXRUeXBlRnJvbUZpbGVOYW1lLCBvYmplY3RLZXlzLCBmaWxlU2l6ZVRvQnl0ZXMsIHJlc29sdmVNYXliZVVybEFyZywgRmV0Y2hDb250ZXh0LCBVcGxvYWRBYm9ydGVkRXJyb3IsIGlzT2JqZWN0IH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5leHBvcnQgeyBVcGxvYWRBYm9ydGVkRXJyb3IsIGdlbmVyYXRlQ2xpZW50RHJvcHpvbmVBY2NlcHQsIGdlbmVyYXRlTWltZVR5cGVzLCBnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuaW1wb3J0IHsgaXNUZXN0IH0gZnJvbSAnc3RkLWVudic7XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjYuMTMuM1wiO1xuXG5jb25zdCB1cGxvYWRNdWx0aXBhcnRXaXRoUHJvZ3Jlc3MgPSAoZmlsZSwgcHJlc2lnbmVkLCBvcHRzKT0+TWljcm8uZ2VuKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgbGV0IHVwbG9hZGVkQnl0ZXMgPSAwO1xuICAgICAgICBjb25zdCBldGFncyA9IHlpZWxkKiBNaWNyby5mb3JFYWNoKHByZXNpZ25lZC51cmxzLCAodXJsLCBpbmRleCk9PntcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHByZXNpZ25lZC5jaHVua1NpemUgKiBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG9mZnNldCArIHByZXNpZ25lZC5jaHVua1NpemUsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBlbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZFBhcnQoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBjaHVuazogY2h1bmssXG4gICAgICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBwcmVzaWduZWQuY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGZpbGVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzOiAoZGVsdGEpPT57XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkQnl0ZXMgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB1cGxvYWRlZEJ5dGVzIC8gZmlsZS5zaXplICogMTAwO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLm9uVXBsb2FkUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5waXBlKE1pY3JvLm1hcCgodGFnKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBpbmRleCArIDFcbiAgICAgICAgICAgICAgICB9KSksIE1pY3JvLnJldHJ5KHtcbiAgICAgICAgICAgICAgICB3aGlsZTogKGVycm9yKT0+ZXJyb3IgaW5zdGFuY2VvZiBSZXRyeUVycm9yLFxuICAgICAgICAgICAgICAgIHRpbWVzOiBpc1Rlc3QgPyAzIDogMTAsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGU6IGV4cG9uZW50aWFsRGVsYXkoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeTogXCJpbmhlcml0XCJcbiAgICAgICAgfSkucGlwZShNaWNyby50YXBFcnJvcigoZXJyb3IpPT5vcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAgICAgdXBsb2FkSWQ6IHByZXNpZ25lZC51cGxvYWRJZCxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VQcm92aWRlckVycm9yOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAvLyBUZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgdXBsb2FkIGlzIGNvbXBsZXRlXG4gICAgICAgIHlpZWxkKiBvcHRzLnJlcG9ydEV2ZW50VG9VVChcIm11bHRpcGFydC1jb21wbGV0ZVwiLCB7XG4gICAgICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIGV0YWdzXG4gICAgICAgIH0pO1xuICAgIH0pO1xuY29uc3QgdXBsb2FkUGFydCA9IChvcHRzKT0+TWljcm8uYXN5bmMoKHJlc3VtZSk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIG9wdHMudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgb3B0cy5maWxlVHlwZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiLCBjb250ZW50RGlzcG9zaXRpb24ob3B0cy5jb250ZW50RGlzcG9zaXRpb24sIG9wdHMuZmlsZU5hbWUpKTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpPT57XG4gICAgICAgICAgICBjb25zdCBldGFnID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiRXRhZ1wiKTtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OSAmJiBldGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VtZShNaWNyby5zdWNjZWVkKGV0YWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bWUoTWljcm8uZmFpbChuZXcgUmV0cnlFcnJvcigpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpPT5yZXN1bWUoTWljcm8uZmFpbChuZXcgUmV0cnlFcnJvcigpKSkpO1xuICAgICAgICBsZXQgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGUpPT57XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGUubG9hZGVkIC0gbGFzdFByb2dyZXNzO1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzICs9IGRlbHRhO1xuICAgICAgICAgICAgb3B0cy5vblByb2dyZXNzKGRlbHRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHhoci5zZW5kKG9wdHMuY2h1bmspO1xuICAgICAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uIHRoYXQgcnVucyBvbiBpbnRlcnJ1cHRpb25cbiAgICAgICAgcmV0dXJuIE1pY3JvLnN5bmMoKCk9Pnhoci5hYm9ydCgpKTtcbiAgICB9KTtcblxuY29uc3QgdXBsb2FkUHJlc2lnbmVkUG9zdFdpdGhQcm9ncmVzcyA9IChmaWxlLCBwcmVzaWduZWQsIG9wdHMpPT5NaWNyby5hc3luYygocmVzdW1lKT0+e1xuICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oXCJQT1NUXCIsIHByZXNpZ25lZC51cmwpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL3htbFwiKTtcbiAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKHsgbG9hZGVkLCB0b3RhbCB9KT0+e1xuICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogbG9hZGVkIC8gdG90YWwgKiAxMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpPT5yZXN1bWUoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCA/IE1pY3JvLnN1Y2NlZWQobnVsbCkgOiBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAgICAgdXBsb2FkSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlUHJvdmlkZXJFcnJvcjogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKT0+cmVzdW1lKG9wdHMucmVwb3J0RXZlbnRUb1VUKFwiZmFpbHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgICAgICB1cGxvYWRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhwcmVzaWduZWQuZmllbGRzKS5mb3JFYWNoKChbaywgdl0pPT5mb3JtRGF0YS5hcHBlbmQoaywgdikpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpOyAvLyBGaWxlIGRhdGEgKipNVVNUIEdPIExBU1QqKlxuICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgICAgIHJldHVybiBNaWNyby5zeW5jKCgpPT57XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbmNvbnN0IG1heWJlUGFyc2VSZXNwb25zZVhNTCA9IChtYXliZVhtbCk9PntcbiAgICBjb25zdCBjb2RlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPENvZGU+KC4qPyk8XFwvQ29kZT4vcyk7XG4gICAgY29uc3QgbWVzc2FnZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxNZXNzYWdlPiguKj8pPFxcL01lc3NhZ2U+L3MpO1xuICAgIGNvbnN0IGNvZGUgPSBjb2RlTWF0Y2g/LlsxXTtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZU1hdGNoPy5bMV07XG4gICAgaWYgKCFjb2RlIHx8ICFtZXNzYWdlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZVtjb2RlXSA/PyBERUZBVUxUX0VSUk9SX0NPREUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICB9O1xufTtcbi8qKlxuICogTWFwIFMzIGVycm9yIGNvZGVzIHRvIFVwbG9hZFRoaW5nIGVycm9yIGNvZGVzXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgUzMgZXJyb3IgY29kZXMsIGJhc2VkIG9uIHdoYXQgc2VlbWVkIG1vc3QgbGlrZWx5IHRvXG4gKiBvY2N1ciBpbiB1cGxvYWR0aGluZy4gRm9yIGEgZnVsbCBsaXN0IG9mIFMzIGVycm9yIGNvZGVzLCBzZWU6XG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9FcnJvclJlc3BvbnNlcy5odG1sXG4gKi8gY29uc3QgREVGQVVMVF9FUlJPUl9DT0RFID0gXCJVUExPQURfRkFJTEVEXCI7XG5jb25zdCBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSA9IHtcbiAgICBBY2Nlc3NEZW5pZWQ6IFwiRk9SQklEREVOXCIsXG4gICAgRW50aXR5VG9vU21hbGw6IFwiVE9PX1NNQUxMXCIsXG4gICAgRW50aXR5VG9vTGFyZ2U6IFwiVE9PX0xBUkdFXCIsXG4gICAgRXhwaXJlZFRva2VuOiBcIkZPUkJJRERFTlwiLFxuICAgIEluY29ycmVjdE51bWJlck9mRmlsZXNJblBvc3RSZXF1ZXN0OiBcIlRPT19NQU5ZX0ZJTEVTXCIsXG4gICAgSW50ZXJuYWxFcnJvcjogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICBLZXlUb29Mb25nRXJyb3I6IFwiS0VZX1RPT19MT05HXCIsXG4gICAgTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkOiBcIlRPT19MQVJHRVwiXG59O1xuXG5jb25zdCBjcmVhdGVBUElSZXF1ZXN0VXJsID0gKGNvbmZpZyk9PntcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNvbmZpZy51cmwpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuc2VhcmNoKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJhY3Rpb25UeXBlXCIsIGNvbmZpZy5hY3Rpb25UeXBlKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJzbHVnXCIsIGNvbmZpZy5zbHVnKTtcbiAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdXJsO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIFwiY2xpZW50XCIgZm9yIHJlcG9ydGluZyBldmVudHMgdG8gdGhlIFVwbG9hZFRoaW5nIHNlcnZlciB2aWEgdGhlIHVzZXIncyBBUEkgZW5kcG9pbnQuXG4gKiBFdmVudHMgYXJlIGhhbmRsZWQgaW4gXCIuL2hhbmRsZXIudHMgc3RhcnRpbmcgYXQgTDExMlwiXG4gKi8gY29uc3QgY3JlYXRlVVRSZXBvcnRlciA9IChjZmcpPT4odHlwZSwgcGF5bG9hZCk9Pk1pY3JvLmdlbihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBjcmVhdGVBUElSZXF1ZXN0VXJsKHtcbiAgICAgICAgICAgICAgICB1cmw6IGNmZy51cmwsXG4gICAgICAgICAgICAgICAgc2x1ZzogY2ZnLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgIGFjdGlvblR5cGU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB0eXBlb2YgY2ZnLmhlYWRlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGNmZy5oZWFkZXJzKCkgOiBjZmcuaGVhZGVycztcbiAgICAgICAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSB5aWVsZCogTWljcm8ucHJvbWlzZSgoKT0+aGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkKiBmZXRjaEVmZih1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1wYWNrYWdlXCI6IGNmZy5wYWNrYWdlLFxuICAgICAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uJDEsXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5waXBlKE1pY3JvLmFuZFRoZW4ocGFyc2VSZXNwb25zZUpzb24pLCAvKipcbiAgICAgICAgICogV2UgZG9uJ3QgX25lZWRfIHRvIHZhbGlkYXRlIHRoZSByZXNwb25zZSBoZXJlLCBqdXN0IGNhc3QgaXQgZm9yIG5vdy5cbiAgICAgICAgICogQXMgb2Ygbm93LCBAZWZmZWN0L3NjaGVtYSBpbmNsdWRlcyBxdWl0ZSBhIGZldyBieXRlcyB3ZSBjdXQgb3V0IGJ5IHRoaXMuLi5cbiAgICAgICAgICogV2UgaGF2ZSBcInN0cm9uZyB0eXBpbmdcIiBvbiB0aGUgYmFja2VuZCB0aGF0IGVuc3VyZXMgdGhlIHNoYXBlIHNob3VsZCBtYXRjaC5cbiAgICAgICAgICovIE1pY3JvLm1hcCh1bnNhZmVDb2VyY2UpLCBNaWNyby5jYXRjaFRhZyhcIkZldGNoRXJyb3JcIiwgKGUpPT5NaWNyby5mYWlsKG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9DTElFTlRfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byByZXBvcnQgZXZlbnQgXCIke3R5cGV9XCIgdG8gVXBsb2FkVGhpbmcgc2VydmVyYCxcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgICAgICAgICB9KSkpLCBNaWNyby5jYXRjaFRhZyhcIkJhZFJlcXVlc3RFcnJvclwiLCAoZSk9Pk1pY3JvLmZhaWwobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZShlLnN0YXR1cyksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUuZ2V0TWVzc2FnZSgpLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogZS5qc29uXG4gICAgICAgICAgICAgICAgfSkpKSwgTWljcm8uY2F0Y2hUYWcoXCJJbnZhbGlkSnNvblwiLCAoZSk9Pk1pY3JvLmZhaWwobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX0NMSUVOVF9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBmcm9tIFVwbG9hZFRoaW5nIHNlcnZlclwiLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogZVxuICAgICAgICAgICAgICAgIH0pKSkpO1xuICAgICAgICAgICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoeSBpc24ndCB0aGlzIG5hcnJvd2VkIGF1dG9tYXRpY2FsbHk/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1heWJlUGFyc2VSZXNwb25zZVhNTChwLnN0b3JhZ2VQcm92aWRlckVycm9yID8/IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZD8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBwYXJzZWQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcGFyc2VkLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHVwbG9hZCBmaWxlICR7cC5maWxlTmFtZX0gdG8gUzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcC5zdG9yYWdlUHJvdmlkZXJFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGEgZmlsZSBpcyBvZiBhIHZhbGlkIHR5cGUgZ2l2ZW4gYSByb3V0ZSBjb25maWdcbiAqIEBwdWJsaWNcbiAqLyBjb25zdCBpc1ZhbGlkRmlsZVR5cGUgPSAoZmlsZSwgcm91dGVDb25maWcpPT5NaWNyby5ydW5TeW5jKGdldFR5cGVGcm9tRmlsZU5hbWUoZmlsZS5uYW1lLCBvYmplY3RLZXlzKHJvdXRlQ29uZmlnKSkucGlwZShNaWNyby5tYXAoKHR5cGUpPT5maWxlLnR5cGUuaW5jbHVkZXModHlwZSkpLCBNaWNyby5vckVsc2VTdWNjZWVkKCgpPT5mYWxzZSkpKTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCBhIGZpbGUgaXMgb2YgYSB2YWxpZCBzaXplIGdpdmVuIGEgcm91dGUgY29uZmlnXG4gKiBAcHVibGljXG4gKi8gY29uc3QgaXNWYWxpZEZpbGVTaXplID0gKGZpbGUsIHJvdXRlQ29uZmlnKT0+TWljcm8ucnVuU3luYyhnZXRUeXBlRnJvbUZpbGVOYW1lKGZpbGUubmFtZSwgb2JqZWN0S2V5cyhyb3V0ZUNvbmZpZykpLnBpcGUoTWljcm8uZmxhdE1hcCgodHlwZSk9PmZpbGVTaXplVG9CeXRlcyhyb3V0ZUNvbmZpZ1t0eXBlXS5tYXhGaWxlU2l6ZSkpLCBNaWNyby5tYXAoKG1heEZpbGVTaXplKT0+ZmlsZS5zaXplIDw9IG1heEZpbGVTaXplKSwgTWljcm8ub3JFbHNlU3VjY2VlZCgoKT0+ZmFsc2UpKSk7XG4vKipcbiAqIEdlbmVyYXRlIGEgdHlwZWQgdXBsb2FkZXIgZm9yIGEgZ2l2ZW4gRmlsZVJvdXRlclxuICogQHB1YmxpY1xuICovIGNvbnN0IGdlblVwbG9hZGVyID0gKGluaXRPcHRzKT0+e1xuICAgIHJldHVybiAoZW5kcG9pbnQsIG9wdHMpPT51cGxvYWRGaWxlc0ludGVybmFsKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgdXJsOiByZXNvbHZlTWF5YmVVcmxBcmcoaW5pdE9wdHM/LnVybCksXG4gICAgICAgICAgICBwYWNrYWdlOiBpbml0T3B0cy5wYWNrYWdlLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgaW5wdXQ6IG9wdHMuaW5wdXRcbiAgICAgICAgfSkucGlwZShNaWNyby5wcm92aWRlU2VydmljZShGZXRjaENvbnRleHQsIHtcbiAgICAgICAgICAgIGZldGNoOiBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyksXG4gICAgICAgICAgICBiYXNlSGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24kMSxcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYXBpLWtleVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWZlLXBhY2thZ2VcIjogaW5pdE9wdHMucGFja2FnZSxcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYmUtYWRhcHRlclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIChlKT0+TWljcm8ucnVuUHJvbWlzZUV4aXQoZSwgb3B0cy5zaWduYWwgPyB7XG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbFxuICAgICAgICAgICAgfSA6IHt9KSkudGhlbigoZXhpdCk9PntcbiAgICAgICAgICAgIGlmIChleGl0Ll90YWcgPT09IFwiUmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGl0LnJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleGl0LmxlZnQuX3RhZyA9PT0gXCJJbnRlcnJ1cHRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IE1pY3JvLmNhdXNlU3F1YXNoKGV4aXQubGVmdCk7XG4gICAgICAgIH0pO1xufTtcbmNvbnN0IHVwbG9hZEZpbGVzSW50ZXJuYWwgPSAoZW5kcG9pbnQsIG9wdHMpPT57XG4gICAgLy8gY2xhc3NpYyBzZXJ2aWNlIHJpZ2h0IGhlcmVcbiAgICBjb25zdCByZXBvcnRFdmVudFRvVVQgPSBjcmVhdGVVVFJlcG9ydGVyKHtcbiAgICAgICAgZW5kcG9pbnQ6IFN0cmluZyhlbmRwb2ludCksXG4gICAgICAgIHBhY2thZ2U6IG9wdHMucGFja2FnZSxcbiAgICAgICAgdXJsOiByZXNvbHZlTWF5YmVVcmxBcmcob3B0cy51cmwpLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVwb3J0RXZlbnRUb1VUKFwidXBsb2FkXCIsIHtcbiAgICAgICAgaW5wdXQ6IFwiaW5wdXRcIiBpbiBvcHRzID8gb3B0cy5pbnB1dCA6IG51bGwsXG4gICAgICAgIGZpbGVzOiBvcHRzLmZpbGVzLm1hcCgoZik9Pih7XG4gICAgICAgICAgICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IGYuc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmLnR5cGVcbiAgICAgICAgICAgIH0pKVxuICAgIH0pLnBpcGUoTWljcm8uZmxhdE1hcCgocmVzcG9uc2VzKT0+TWljcm8uZm9yRWFjaChyZXNwb25zZXMsIChwcmVzaWduZWQpPT51cGxvYWRGaWxlKFN0cmluZyhlbmRwb2ludCksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIHJlcG9ydEV2ZW50VG9VVFxuICAgICAgICAgICAgfSwgcHJlc2lnbmVkKS5waXBlKE1pY3JvLm9uSW50ZXJydXB0KHJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAgICAgdXBsb2FkSWQ6IFwidXBsb2FkSWRcIiBpbiBwcmVzaWduZWQgPyBwcmVzaWduZWQudXBsb2FkSWQgOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBwcmVzaWduZWQuZmlsZU5hbWVcbiAgICAgICAgICAgIH0pLnBpcGUoTWljcm8uaWdub3JlKSkpLCB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeTogNlxuICAgICAgICB9KSkpO1xufTtcbmNvbnN0IGlzUG9sbGluZ1Jlc3BvbnNlID0gKGlucHV0KT0+e1xuICAgIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGlucHV0LnN0YXR1cyA9PT0gXCJkb25lXCIpIHJldHVybiBcImNhbGxiYWNrRGF0YVwiIGluIGlucHV0O1xuICAgIHJldHVybiBpbnB1dC5zdGF0dXMgPT09IFwic3RpbGwgd2FpdGluZ1wiO1xufTtcbmNvbnN0IGlzUG9sbGluZ0RvbmUgPSAoaW5wdXQpPT57XG4gICAgcmV0dXJuIGlucHV0LnN0YXR1cyA9PT0gXCJkb25lXCI7XG59O1xuY29uc3QgdXBsb2FkRmlsZSA9IChzbHVnLCBvcHRzLCBwcmVzaWduZWQpPT5BcnIuZmluZEZpcnN0KG9wdHMuZmlsZXMsIChmaWxlKT0+ZmlsZS5uYW1lID09PSBwcmVzaWduZWQuZmlsZU5hbWUpLnBpcGUoTWljcm8uZnJvbU9wdGlvbiwgTWljcm8ubWFwRXJyb3IoKCk9PntcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIiwgcHJlc2lnbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIixcbiAgICAgICAgICAgIGNhdXNlOiBgRXhwZWN0ZWQgZmlsZSB3aXRoIG5hbWUgJHtwcmVzaWduZWQuZmlsZU5hbWV9IGJ1dCBnb3QgJyR7b3B0cy5maWxlcy5qb2luKFwiLFwiKX0nYFxuICAgICAgICB9KTtcbiAgICB9KSwgTWljcm8udGFwKChmaWxlKT0+b3B0cy5vblVwbG9hZEJlZ2luPy4oe1xuICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lXG4gICAgICAgIH0pKSwgTWljcm8udGFwKChmaWxlKT0+XCJ1cmxzXCIgaW4gcHJlc2lnbmVkID8gdXBsb2FkTXVsdGlwYXJ0V2l0aFByb2dyZXNzKGZpbGUsIHByZXNpZ25lZCwgb3B0cykgOiB1cGxvYWRQcmVzaWduZWRQb3N0V2l0aFByb2dyZXNzKGZpbGUsIHByZXNpZ25lZCwgb3B0cykpLCBNaWNyby56aXAoZmV0Y2hFZmYocHJlc2lnbmVkLnBvbGxpbmdVcmwsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogcHJlc2lnbmVkLnBvbGxpbmdKd3RcbiAgICAgICAgfVxuICAgIH0pLnBpcGUoTWljcm8uZmxhdE1hcChwYXJzZVJlc3BvbnNlSnNvbiksIE1pY3JvLmNhdGNoVGFnKFwiQmFkUmVxdWVzdEVycm9yXCIsIChlKT0+TWljcm8uZmFpbChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZShlLnN0YXR1cyksXG4gICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICBjYXVzZTogZVxuICAgICAgICB9KSkpLCBNaWNyby5maWx0ZXJPckZhaWxDYXVzZShpc1BvbGxpbmdSZXNwb25zZSwgKF8pPT5NaWNyby5jYXVzZURpZShcInJlY2VpdmVkIGEgbm9uIFBvbGxpbmdSZXNwb25zZSBmcm9tIHRoZSBwb2xsaW5nIGVuZHBvaW50XCIpKSwgTWljcm8uZmlsdGVyT3JGYWlsKGlzUG9sbGluZ0RvbmUsICgpPT5uZXcgUmV0cnlFcnJvcigpKSwgTWljcm8ubWFwKCh7IGNhbGxiYWNrRGF0YSB9KT0+Y2FsbGJhY2tEYXRhKSwgTWljcm8ucmV0cnkoe1xuICAgICAgICB3aGlsZTogKHJlcyk9PnJlcy5fdGFnID09PSBcIlJldHJ5RXJyb3JcIixcbiAgICAgICAgc2NoZWR1bGU6IGV4cG9uZW50aWFsRGVsYXkoKVxuICAgIH0pLCBNaWNyby53aGVuKCgpPT4hb3B0cy5za2lwUG9sbGluZyksIE1pY3JvLm1hcChPcHRpb24uZ2V0T3JOdWxsKSwgTWljcm8ubWFwKHVuc2FmZUNvZXJjZSkpKSwgTWljcm8ubWFwKChbZmlsZSwgc2VydmVyRGF0YV0pPT4oe1xuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAga2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgICAgIHVybDogcHJlc2lnbmVkLmZpbGVVcmwsXG4gICAgICAgICAgICBhcHBVcmw6IHByZXNpZ25lZC5hcHBVcmwsXG4gICAgICAgICAgICBjdXN0b21JZDogcHJlc2lnbmVkLmN1c3RvbUlkLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlXG4gICAgICAgIH0pKSk7XG5cbmV4cG9ydCB7IGdlblVwbG9hZGVyLCBpc1ZhbGlkRmlsZVNpemUsIGlzVmFsaWRGaWxlVHlwZSwgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;